'use strict';(function(f,c){"object"===typeof exports&&"undefined"!==typeof module?c(exports,require("three")):"function"===typeof define&&define.amd?define(["exports","three"],c):(f="undefined"!==typeof globalThis?globalThis:f||self,c(f.troika_three_utils={},f.THREE))})(this,function(f,c){function t(b){return b.replace(/^[ \t]*#include +<([\w\d./]+)>/gm,function(a,b){return(b=c.ShaderChunk[b])?t(b):a})}function n(b,a){var g=C(a),d=q.get(b);d||q.set(b,d=Object.create(null));if(d[g])return new d[g];
var e="_onBeforeCompile"+g,f=function(h){b.onBeforeCompile.call(this,h);var d=g+"|||"+h.vertexShader+"|||"+h.fragmentShader,c=v[d];c||(c=D(h,a,g),c=v[d]=c);h.vertexShader=c.vertexShader;h.fragmentShader=c.fragmentShader;m(h.uniforms,this.uniforms);a.timeUniform&&(h.uniforms[a.timeUniform]={get value(){return Date.now()-E}});if(this[e])this[e](h)},r=function(){return w(a.chained?b:b.clone())},w=function(d){var h=Object.create(d,p);Object.defineProperty(h,"baseMaterial",{value:b});Object.defineProperty(h,
"id",{value:F++});var e=4294967295*Math.random()|0;var c=4294967295*Math.random()|0,f=4294967295*Math.random()|0,u=4294967295*Math.random()|0;e=(k[e&255]+k[e>>8&255]+k[e>>16&255]+k[e>>24&255]+"-"+k[c&255]+k[c>>8&255]+"-"+k[c>>16&15|64]+k[c>>24&255]+"-"+k[f&63|128]+k[f>>8&255]+"-"+k[f>>16&255]+k[f>>24&255]+k[u&255]+k[u>>8&255]+k[u>>16&255]+k[u>>24&255]).toUpperCase();h.uuid=e;h.uniforms=m({},d.uniforms,a.uniforms);h.defines=m({},d.defines,a.defines);h.defines["TROIKA_DERIVED_MATERIAL_"+g]="";h.extensions=
m({},d.extensions,a.extensions);h._listeners=void 0;return h},p={constructor:{value:r},isDerivedMaterial:{value:!0},customProgramCacheKey:{writable:!0,configurable:!0,value:function(){return g}},onBeforeCompile:{get:function(){return f},set:function(a){this[e]=a}},copy:{writable:!0,configurable:!0,value:function(a){b.copy.call(this,a);b.isShaderMaterial||b.isDerivedMaterial||(m(this.extensions,a.extensions),m(this.defines,a.defines),m(this.uniforms,c.UniformsUtils.clone(a.uniforms)));return this}},
clone:{writable:!0,configurable:!0,value:function(){var a=new b.constructor;return w(a).copy(this)}},getDepthMaterial:{writable:!0,configurable:!0,value:function(){var d=this._depthMaterial;d||(d=this._depthMaterial=n(b.isDerivedMaterial?b.getDepthMaterial():new c.MeshDepthMaterial({depthPacking:c.RGBADepthPacking}),a),d.defines.IS_DEPTH_MATERIAL="",d.uniforms=this.uniforms);return d}},getDistanceMaterial:{writable:!0,configurable:!0,value:function(){var d=this._distanceMaterial;d||(d=this._distanceMaterial=
n(b.isDerivedMaterial?b.getDistanceMaterial():new c.MeshDistanceMaterial,a),d.defines.IS_DISTANCE_MATERIAL="",d.uniforms=this.uniforms);return d}},dispose:{writable:!0,configurable:!0,value:function(){var a=this._depthMaterial,d=this._distanceMaterial;a&&a.dispose();d&&d.dispose();b.dispose.call(this)}}};d[g]=r;return new r}function D(b,a,g){var d=b.vertexShader,e=b.fragmentShader;b=a.vertexDefs;var c=a.vertexMainIntro,f=a.vertexMainOutro,k=a.vertexTransform,p=a.fragmentDefs,h=a.fragmentMainIntro,
m=a.fragmentMainOutro,l=a.fragmentColorTransform,n=a.customRewriter;a=a.timeUniform;b=b||"";c=c||"";f=f||"";p=p||"";h=h||"";m=m||"";if(k||n)d=t(d);if(l||n)e=e.replace(/^[ \t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,"\n//!BEGIN_POST_CHUNK $1\n$&\n//!END_POST_CHUNK\n"),e=t(e);n&&(e=n({vertexShader:d,fragmentShader:e}),d=e.vertexShader,e=e.fragmentShader);if(l){var q=[];e=e.replace(/^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,function(a){q.push(a);
return""});m=l+"\n"+q.join("\n")+"\n"+m}a&&(l="\nuniform float "+a+";\n",b=l+b,p=l+p);k&&(b=b+"\nvoid troikaVertexTransform"+g+"(inout vec3 position, inout vec3 normal, inout vec2 uv) {\n  "+k+"\n}\n",c="\ntroika_position_"+g+" = vec3(position);\ntroika_normal_"+g+" = vec3(normal);\ntroika_uv_"+g+" = vec2(uv);\ntroikaVertexTransform"+g+"(troika_position_"+g+", troika_normal_"+g+", troika_uv_"+g+");\n"+c+"\n",d=("vec3 troika_position_"+g+";\nvec3 troika_normal_"+g+";\nvec2 troika_uv_"+g+";\n"+d+"\n").replace(/\b(position|normal|uv)\b/g,
function(a,d,b,c){return/\battribute\s+vec[23]\s+$/.test(c.substr(0,b))?d:"troika_"+d+"_"+g}));d=x(d,g,b,c,f);e=x(e,g,p,h,m);return{vertexShader:d,fragmentShader:e}}function x(b,a,c,d,e){if(d||e||c)b=b.replace(y,"\n"+c+"\nvoid troikaOrigMain"+a+"() {"),b+="\nvoid main() {\n  "+d+"\n  troikaOrigMain"+a+"();\n  "+e+"\n}";return b}function G(b,a){return"uniforms"===b?void 0:"function"===typeof a?a.toString():a}function C(b){b=JSON.stringify(b,G);var a=z.get(b);null==a&&z.set(b,a=++H);return a}for(var y=
/\bvoid\s+main\s*\(\s*\)\s*{/g,k=[],l=0;256>l;l++)k[l]=(16>l?"0":"")+l.toString(16);var m=Object.assign||function(){for(var b=arguments,a=arguments[0],c=1,d=arguments.length;c<d;c++){var e=b[c];if(e)for(var f in e)e.hasOwnProperty(f)&&(a[f]=e[f])}return a},E=Date.now(),q=new WeakMap,v=new Map,F=1E10,H=0,z=new Map,I={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",
MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},A=null,B=new c.MeshStandardMaterial({color:16777215,side:c.DoubleSide});l=function(b){function a(){b.call(this,a.getGeometry(),B);this.pointA=new c.Vector3;this.controlA=new c.Vector3;this.controlB=new c.Vector3;this.pointB=new c.Vector3;this.radius=.01;this.dashArray=new c.Vector2;
this.dashOffset=0;this.frustumCulled=!1}b&&(a.__proto__=b);a.prototype=Object.create(b&&b.prototype);a.prototype.constructor=a;var g={material:{configurable:!0},customDepthMaterial:{configurable:!0},customDistanceMaterial:{configurable:!0}};a.getGeometry=function(){return A||(A=(new c.CylinderBufferGeometry(1,1,1,6,64)).translate(0,.5,0))};g.material.get=function(){var a=this._derivedMaterial,b=this._baseMaterial||this._defaultMaterial||(this._defaultMaterial=B.clone());a&&a.baseMaterial===b||(a=
this._derivedMaterial=n(b,{chained:!0,uniforms:{pointA:{value:new c.Vector3},controlA:{value:new c.Vector3},controlB:{value:new c.Vector3},pointB:{value:new c.Vector3},radius:{value:.01},dashing:{value:new c.Vector3}},vertexDefs:"\nuniform vec3 pointA;\nuniform vec3 controlA;\nuniform vec3 controlB;\nuniform vec3 pointB;\nuniform float radius;\nvarying float bezierT;\n\nvec3 cubicBezier(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\n  float t2 = 1.0 - t;\n  float b0 = t2 * t2 * t2;\n  float b1 = 3.0 * t * t2 * t2;\n  float b2 = 3.0 * t * t * t2;\n  float b3 = t * t * t;\n  return b0 * p1 + b1 * c1 + b2 * c2 + b3 * p2;\n}\n\nvec3 cubicBezierDerivative(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\n  float t2 = 1.0 - t;\n  return -3.0 * p1 * t2 * t2 +\n    c1 * (3.0 * t2 * t2 - 6.0 * t2 * t) +\n    c2 * (6.0 * t2 * t - 3.0 * t * t) +\n    3.0 * p2 * t * t;\n}\n",
vertexTransform:'\nfloat t = position.y;\nbezierT = t;\nvec3 bezierCenterPos = cubicBezier(pointA, controlA, controlB, pointB, t);\nvec3 bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t));\n\n// Make "sideways" always perpendicular to the camera ray; this ensures that any twists\n// in the cylinder occur where you won\'t see them: \nvec3 viewDirection = normalMatrix * vec3(0.0, 0.0, 1.0);\nif (bezierDir == viewDirection) {\n  bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t == 1.0 ? t - 0.0001 : t + 0.0001));\n}\nvec3 sideways = normalize(cross(bezierDir, viewDirection));\nvec3 upish = normalize(cross(sideways, bezierDir));\n\n// Build a matrix for transforming this disc in the cylinder:\nmat4 discTx;\ndiscTx[0].xyz = sideways * radius;\ndiscTx[1].xyz = bezierDir * radius;\ndiscTx[2].xyz = upish * radius;\ndiscTx[3].xyz = bezierCenterPos;\ndiscTx[3][3] = 1.0;\n\n// Apply transform, ignoring original y\nposition = (discTx * vec4(position.x, 0.0, position.z, 1.0)).xyz;\nnormal = normalize(mat3(discTx) * normal);\n',
fragmentDefs:"\nuniform vec3 dashing;\nvarying float bezierT;\n",fragmentMainIntro:"\nif (dashing.x + dashing.y > 0.0) {\n  float dashFrac = mod(bezierT - dashing.z, dashing.x + dashing.y);\n  if (dashFrac > dashing.x) {\n    discard;\n  }\n}\n"}),b.addEventListener("dispose",function r(){b.removeEventListener("dispose",r);a.dispose()}));return a};g.material.set=function(a){this._baseMaterial=a};g.customDepthMaterial.get=function(){return this.material.getDepthMaterial()};g.customDistanceMaterial.get=
function(){return this.material.getDistanceMaterial()};a.prototype.onBeforeRender=function(a){a=this.material.uniforms;var b=this.controlA,c=this.controlB,d=this.pointB,g=this.radius,f=this.dashArray,h=this.dashOffset;a.pointA.value.copy(this.pointA);a.controlA.value.copy(b);a.controlB.value.copy(c);a.pointB.value.copy(d);a.radius.value=g;a.dashing.value.set(f.x,f.y,h||0)};a.prototype.raycast=function(a,b){};Object.defineProperties(a.prototype,g);return a}(c.Mesh);f.BezierMesh=l;f.createDerivedMaterial=
n;f.expandShaderIncludes=t;f.getShaderUniformTypes=function(b){for(var a=/\buniform\s+(int|float|vec[234])\s+([A-Za-z_][\w]*)/g,c=Object.create(null),d;null!==(d=a.exec(b));)c[d[2]]=d[1];return c};f.getShadersForMaterial=function(b){var a=I[b.type];return a?c.ShaderLib[a]:b};f.invertMatrix4=function(b,a){void 0===a&&(a=new c.Matrix4);"function"===typeof a.invert?a.copy(b).invert():a.getInverse(b);return a};f.voidMainRegExp=y;Object.defineProperty(f,"__esModule",{value:!0})})
